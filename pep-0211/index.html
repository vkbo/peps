
<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PEP 211 – Adding A New Outer Product Operator | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png"/>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/mq.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)"/>
</head>
<body>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 211 – Adding A New Outer Product Operator</li>
            </ul>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 211 – Adding A New Outer Product Operator</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">PEP</dt>
<dd class="field-odd">211</dd>
<dt class="field-even">Title</dt>
<dd class="field-even">Adding A New Outer Product Operator</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd">gvwilson&#32;&#97;t&#32;ddj.com (Greg Wilson)</dd>
<dt class="field-even">Status</dt>
<dd class="field-even">Rejected</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd">Standards Track</dd>
<dt class="field-even">Created</dt>
<dd class="field-even">15-Jul-2000</dd>
<dt class="field-odd">Python-Version</dt>
<dd class="field-odd">2.1</dd>
<dt class="field-even">Post-History</dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Resolution</dt>
<dd class="field-odd"><a class="reference external" href="https://www.python.org/dev/peps/pep-0465/#rejected-alternatives-to-adding-a-new-operator">https://www.python.org/dev/peps/pep-0465/#rejected-alternatives-to-adding-a-new-operator</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<h2>Contents</h2>
<ul class="simple">
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#iterators">Iterators</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</section>
<section id="introduction">
<h2><a class="toc-backref" href="#introduction">Introduction</a></h2>
<p>This PEP describes a proposal to define <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (pronounced “across”)
as a new outer product operator in Python 2.2.  When applied to
sequences (or other iterable objects), this operator will combine
their iterators, so that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">S</span> <span class="o">@</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>will be equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Classes will be able to overload this operator using the special
methods <code class="docutils literal notranslate"><span class="pre">__across__</span></code>, <code class="docutils literal notranslate"><span class="pre">__racross__</span></code>, and <code class="docutils literal notranslate"><span class="pre">__iacross__</span></code>.  In
particular, the new Numeric module (<a class="reference external" href="../pep-0209">PEP 209</a>) will overload this
operator for multi-dimensional arrays to implement matrix
multiplication.</p>
</section>
<section id="background">
<h2><a class="toc-backref" href="#background">Background</a></h2>
<p>Number-crunching is now just a small part of computing, but many
programmers — including many Python users — still need to
express complex mathematical operations in code.  Most numerical
languages, such as APL, Fortran-90, MATLAB, IDL, and Mathematica,
therefore provide two forms of the common arithmetic operators.
One form works element-by-element, e.g. multiplies corresponding
elements of its matrix arguments.  The other implements the
“mathematical” definition of that operation, e.g. performs
row-column matrix multiplication.</p>
<p>Zhu and Lielens have proposed doubling up Python’s operators in
this way <a class="footnote-reference brackets" href="#id8" id="id1">1</a>.  Their proposal would create six new binary infix
operators, and six new in-place operators.</p>
<p>The original version of this proposal was much more conservative.
The author consulted the developers of GNU Octave <a class="footnote-reference brackets" href="#id9" id="id2">2</a>, an open
source clone of MATLAB.  Its developers agreed that providing an
infix operator for matrix multiplication was important: numerical
programmers really do care whether they have to write <code class="docutils literal notranslate"><span class="pre">mmul(A,B)</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">op</span> <span class="pre">B</span></code>.</p>
<p>On the other hand, when asked how important it was to have infix
operators for matrix solution and other operations, Prof. James
Rawlings replied <a class="footnote-reference brackets" href="#id10" id="id3">3</a>:</p>
<blockquote>
<div>I DON’T think it’s a must have, and I do a lot of matrix
inversion. I cannot remember if its <code class="docutils literal notranslate"><span class="pre">A\b</span></code> or <code class="docutils literal notranslate"><span class="pre">b\A</span></code> so I always
write <code class="docutils literal notranslate"><span class="pre">inv(A)*b</span></code> instead. I recommend dropping <code class="docutils literal notranslate"><span class="pre">\</span></code>.</div></blockquote>
<p>Based on this discussion, and feedback from students at the US
national laboratories and elsewhere, we recommended adding only
one new operator, for matrix multiplication, to Python.</p>
</section>
<section id="iterators">
<h2><a class="toc-backref" href="#iterators">Iterators</a></h2>
<p>The planned addition of iterators to Python 2.2 opens up a broader
scope for this proposal.  As part of the discussion of <a class="reference external" href="../pep-0201">PEP 201</a>,
Lockstep Iteration <a class="footnote-reference brackets" href="#id11" id="id4">4</a>, the author of this proposal conducted an
informal usability experiment <a class="footnote-reference brackets" href="#id12" id="id5">5</a>.  The results showed that users
are psychologically receptive to “cross-product” loop syntax.  For
example, most users expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span><span class="p">;</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">T</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span>
</pre></div>
</div>
<p>to print <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">12</span> <span class="pre">13</span> <span class="pre">21</span> <span class="pre">22</span> <span class="pre">23</span> <span class="pre">31</span> <span class="pre">32</span> <span class="pre">33</span></code>.  We believe that users will
have the same reaction to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">S</span> <span class="o">@</span> <span class="n">T</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</pre></div>
</div>
<p>i.e. that they will naturally interpret this as a tidy way to
write loop nests.</p>
<p>This is where iterators come in.  Actually constructing the
cross-product of two (or more) sequences before executing the loop
would be very expensive.  On the other hand, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> could be defined
to get its arguments’ iterators, and then create an outer iterator
which returns tuples of the values returned by the inner
iterators.</p>
</section>
<section id="discussion">
<h2><a class="toc-backref" href="#discussion">Discussion</a></h2>
<ol class="arabic">
<li>Adding a named function “across” would have less impact on
Python than a new infix operator.  However, this would not make
Python more appealing to numerical programmers, who really do
care whether they can write matrix multiplication using an
operator, or whether they have to write it as a function call.</li>
<li><code class="docutils literal notranslate"><span class="pre">&#64;</span></code> would have be chainable in the same way as comparison
operators, i.e.:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>would have to return <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">3,</span> <span class="pre">5)</span> <span class="pre">...</span> <span class="pre">(2,</span> <span class="pre">4,</span> <span class="pre">6)</span></code>, and <em>not</em>
<code class="docutils literal notranslate"><span class="pre">((1,</span> <span class="pre">3),</span> <span class="pre">5)</span> <span class="pre">...</span> <span class="pre">((2,</span> <span class="pre">4),</span> <span class="pre">6)</span></code>.  This should not require special
support from the parser, as the outer iterator created by the
first <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> could easily be taught how to combine itself with
ordinary iterators.</p>
</li>
<li>There would have to be some way to distinguish restartable
iterators from ones that couldn’t be restarted.  For example,
if <code class="docutils literal notranslate"><span class="pre">S</span></code> is an input stream (e.g. a file), and <code class="docutils literal notranslate"><span class="pre">L</span></code> is a list, then <code class="docutils literal notranslate"><span class="pre">S</span>
<span class="pre">&#64;</span> <span class="pre">L</span></code> is straightforward, but <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">&#64;</span> <span class="pre">S</span></code> is not, since iteration
through the stream cannot be repeated.  This could be treated
as an error, or by having the outer iterator detect
non-restartable inner iterators and cache their values.</li>
<li>Whiteboard testing of this proposal in front of three novice
Python users (all of them experienced programmers) indicates
that users will expect:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;ab&quot;</span> <span class="o">@</span> <span class="s2">&quot;cd&quot;</span>
</pre></div>
</div>
<p>to return four strings, not four tuples of pairs of
characters.  Opinion was divided on what:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">)</span> <span class="o">@</span> <span class="s2">&quot;cd&quot;</span>
</pre></div>
</div>
<p>ought to return…</p>
</li>
</ol>
</section>
<section id="alternatives">
<h2><a class="toc-backref" href="#alternatives">Alternatives</a></h2>
<ol class="arabic">
<li>Do nothing — keep Python simple.<p>This is always the default choice.</p>
</li>
<li>Add a named function instead of an operator.<p>Python is not primarily a numerical language; it may not be worth
complexifying it for this special case.  However, support for real
matrix multiplication <em>is</em> frequently requested, and the proposed
semantics for <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> for built-in sequence types would simplify
expression of a very common idiom (nested loops).</p>
</li>
<li>Introduce prefixed forms of all existing operators, such as
<code class="docutils literal notranslate"><span class="pre">~*</span></code> and <code class="docutils literal notranslate"><span class="pre">~+</span></code>, as proposed in <a class="reference external" href="../pep-0225">PEP 225</a> <a class="footnote-reference brackets" href="#id8" id="id6">1</a>.<p>Our objections to this are that there isn’t enough demand to
justify the additional complexity (see Rawlings’ comments <a class="footnote-reference brackets" href="#id10" id="id7">3</a>),
and that the proposed syntax fails the “low toner” readability
test.</p>
</li>
</ol>
</section>
<section id="acknowledgments">
<h2><a class="toc-backref" href="#acknowledgments">Acknowledgments</a></h2>
<p>I am grateful to Huaiyu Zhu for initiating this discussion, and to
James Rawlings and students in various Python courses for their
discussions of what numerical programmers really care about.</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references">References</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets">1</span><span class='fn-backref''><em> (<a href='#id1'>1</a>, <a href='#id6'>2</a>) </em></span></dt>
<dd><a class="reference external" href="../pep-0225">PEP 225</a>, Elementwise/Objectwise Operators, Zhu, Lielens
<a class="reference external" href="http://www.python.org/dev/peps/pep-0225/">http://www.python.org/dev/peps/pep-0225/</a></dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><a class="reference external" href="http://bevo.che.wisc.edu/octave/">http://bevo.che.wisc.edu/octave/</a></dd>
<dt class="label" id="id10"><span class="brackets">3</span><span class='fn-backref''><em> (<a href='#id3'>1</a>, <a href='#id7'>2</a>) </em></span></dt>
<dd><a class="reference external" href="http://www.egroups.com/message/python-numeric/4">http://www.egroups.com/message/python-numeric/4</a></dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><a class="reference external" href="../pep-0201">PEP 201</a>, Lockstep Iteration, Warsaw
<a class="reference external" href="http://www.python.org/dev/peps/pep-0201/">http://www.python.org/dev/peps/pep-0201/</a></dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-July/006427.html">https://mail.python.org/pipermail/python-dev/2000-July/006427.html</a></dd>
</dl>
</section>
</section>
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/master/pep-0211.txt">https://github.com/python/peps/blob/master/pep-0211.txt</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/master/pep-0211.txt">2021-07-14 18:01:22 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#">PEP 211 – Adding A New Outer Product Operator</a><ul>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#iterators">Iterators</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

            <br />
            <strong><a href="https://github.com/python/peps/blob/master/pep-0211.txt">Page Source (GitHub)</a></strong>
        </nav>
    </section>
    <script src="../_static/doctools.js"></script>
</body>
</html>