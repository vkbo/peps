
<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PEP 213 – Attribute Access Handlers | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png"/>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/mq.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)"/>
</head>
<body>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 213 – Attribute Access Handlers</li>
            </ul>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 213 – Attribute Access Handlers</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">PEP</dt>
<dd class="field-odd">213</dd>
<dt class="field-even">Title</dt>
<dd class="field-even">Attribute Access Handlers</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd">paul&#32;&#97;t&#32;prescod.net (Paul Prescod)</dd>
<dt class="field-even">Status</dt>
<dd class="field-even">Deferred</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd">Standards Track</dd>
<dt class="field-even">Created</dt>
<dd class="field-even">21-Jul-2000</dd>
<dt class="field-odd">Python-Version</dt>
<dd class="field-odd">2.1</dd>
<dt class="field-even">Post-History</dt>
<dd class="field-even"><p></p></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<h2>Contents</h2>
<ul class="simple">
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#justification">Justification</a><ul>
<li><a class="reference internal" href="#scenario-1">Scenario 1</a></li>
<li><a class="reference internal" href="#scenario-2">Scenario 2</a></li>
<li><a class="reference internal" href="#scenario-3">Scenario 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#current-solution">Current Solution</a></li>
<li><a class="reference internal" href="#proposed-syntax">Proposed Syntax</a></li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
<li><a class="reference internal" href="#proposed-implementation">Proposed Implementation</a></li>
<li><a class="reference internal" href="#caveats">Caveats</a></li>
<li><a class="reference internal" href="#note">Note</a></li>
</ul>
</section>
<section id="introduction">
<h2><a class="toc-backref" href="#introduction">Introduction</a></h2>
<p>It is possible (and even relatively common) in Python code and
in extension modules to “trap” when an instance’s client code
attempts to set an attribute and execute code instead. In other
words, it is possible to allow users to use attribute assignment/
retrieval/deletion syntax even though the underlying implementation
is doing some computation rather than directly modifying a
binding.</p>
<p>This PEP describes a feature that makes it easier, more efficient
and safer to implement these handlers for Python instances.</p>
</section>
<section id="justification">
<h2><a class="toc-backref" href="#justification">Justification</a></h2>
<section id="scenario-1">
<h3><a class="toc-backref" href="#scenario-1">Scenario 1</a></h3>
<p>You have a deployed class that works on an attribute named
“stdout”. After a while, you think it would be better to
check that stdout is really an object with a “write” method
at the moment of assignment. Rather than change to a
setstdout method (which would be incompatible with deployed
code) you would rather trap the assignment and check the
object’s type.</p>
</section>
<section id="scenario-2">
<h3><a class="toc-backref" href="#scenario-2">Scenario 2</a></h3>
<p>You want to be as compatible as possible with an object
model that has a concept of attribute assignment. It could
be the W3C Document Object Model or a particular COM
interface (e.g. the PowerPoint interface). In that case
you may well want attributes in the model to show up as
attributes in the Python interface, even though the
underlying implementation may not use attributes at all.</p>
</section>
<section id="scenario-3">
<h3><a class="toc-backref" href="#scenario-3">Scenario 3</a></h3>
<p>A user wants to make an attribute read-only.</p>
<p>In short, this feature allows programmers to separate the
interface of their module from the underlying implementation
for whatever purpose. Again, this is not a new feature but
merely a new syntax for an existing convention.</p>
</section>
</section>
<section id="current-solution">
<h2><a class="toc-backref" href="#current-solution">Current Solution</a></h2>
<p>To make some attributes read-only:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s2">&quot;readonlyattr&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">elif</span> <span class="n">name</span><span class="o">==</span><span class="s2">&quot;readonlyattr2&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">val</span>
</pre></div>
</div>
<p>This has the following problems:</p>
<ol class="arabic simple">
<li>The creator of the method must be intimately aware of whether
somewhere else in the class hierarchy <code class="docutils literal notranslate"><span class="pre">__setattr__</span></code> has also been
trapped for any particular purpose. If so, she must specifically
call that method rather than assigning to the dictionary. There
are many different reasons to overload <code class="docutils literal notranslate"><span class="pre">__setattr__</span></code> so there is a
decent potential for clashes. For instance object database
implementations often overload setattr for an entirely unrelated
purpose.</li>
<li>The string-based switch statement forces all attribute handlers
to be specified in one place in the code. They may then dispatch
to task-specific methods (for modularity) but this could cause
performance problems.</li>
<li>Logic for the setting, getting and deleting must live in
<code class="docutils literal notranslate"><span class="pre">__getattr__</span></code>, <code class="docutils literal notranslate"><span class="pre">__setattr__</span></code> and <code class="docutils literal notranslate"><span class="pre">__delattr__</span></code>. Once again, this can
be mitigated through an extra level of method call but this is
inefficient.</li>
</ol>
</section>
<section id="proposed-syntax">
<h2><a class="toc-backref" href="#proposed-syntax">Proposed Syntax</a></h2>
<p>Special methods should declare themselves with declarations of the
following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">x</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__attr_XXX__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">val</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">==</span><span class="s2">&quot;get&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">someComputedValue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">==</span><span class="s2">&quot;set&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">internal</span><span class="o">=</span><span class="n">someComputedValue</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">==</span><span class="s2">&quot;del&quot;</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal</span>
</pre></div>
</div>
<p>Client code looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fooval</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">foo</span>
<span class="n">x</span><span class="o">.</span><span class="n">foo</span><span class="o">=</span><span class="n">fooval</span><span class="o">+</span><span class="mi">5</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
</div>
</section>
<section id="semantics">
<h2><a class="toc-backref" href="#semantics">Semantics</a></h2>
<p>Attribute references of all three kinds should call the method.
The op parameter can be “get”/”set”/”del”. Of course this string
will be interned so the actual checks for the string will be
very fast.</p>
<p>It is disallowed to actually have an attribute named XXX in the
same instance as a method named __attr_XXX__.</p>
<p>An implementation of __attr_XXX__ takes precedence over an
implementation of <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> based on the principle that
<code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> is supposed to be invoked only after finding an
appropriate attribute has failed.</p>
<p>An implementation of __attr_XXX__ takes precedence over an
implementation of <code class="docutils literal notranslate"><span class="pre">__setattr__</span></code> in order to be consistent. The
opposite choice seems fairly feasible also, however. The same
goes for __del_y__.</p>
</section>
<section id="proposed-implementation">
<h2><a class="toc-backref" href="#proposed-implementation">Proposed Implementation</a></h2>
<p>There is a new object type called an attribute access handler.
Objects of this type have the following attributes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">XXX</span><span class="p">,</span> <span class="ow">not</span> <span class="n">__attr__XXX__</span><span class="p">)</span>
<span class="n">method</span> <span class="p">(</span><span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">method</span> <span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
<p>In PyClass_New, methods of the appropriate form will be detected and
converted into objects (just like unbound method objects). These are
stored in the class <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> under the name XXX. The original method
is stored as an unbound method under its original name.</p>
<p>If there are any attribute access handlers in an instance at all,
a flag is set. Let’s call it “I_have_computed_attributes” for
now. Derived classes inherit the flag from base classes. Instances
inherit the flag from classes.</p>
<p>A get proceeds as usual until just before the object is returned.
In addition to the current check whether the returned object is a
method it would also check whether a returned object is an access
handler. If so, it would invoke the getter method and return
the value. To remove an attribute access handler you could directly
fiddle with the dictionary.</p>
<p>A set proceeds by checking the “I_have_computed_attributes” flag. If
it is not set, everything proceeds as it does today. If it is set
then we must do a dictionary get on the requested object name. If it
returns an attribute access handler then we call the setter function
with the value. If it returns any other object then we discard the
result and continue as we do today. Note that having an attribute
access handler will mildly affect attribute “setting” performance for
all sets on a particular instance, but no more so than today, using
<code class="docutils literal notranslate"><span class="pre">__setattr__</span></code>. Gets are more efficient than they are today with
<code class="docutils literal notranslate"><span class="pre">__getattr__</span></code>.</p>
<p>The I_have_computed_attributes flag is intended to eliminate the
performance degradation of an extra “get” per “set” for objects not
using this feature. Checking this flag should have minuscule
performance implications for all objects.</p>
<p>The implementation of delete is analogous to the implementation
of set.</p>
</section>
<section id="caveats">
<h2><a class="toc-backref" href="#caveats">Caveats</a></h2>
<ol class="arabic">
<li>You might note that I have not proposed any logic to keep
the I_have_computed_attributes flag up to date as attributes
are added and removed from the instance’s dictionary. This is
consistent with current Python. If you add a <code class="docutils literal notranslate"><span class="pre">__setattr__</span></code> method
to an object after it is in use, that method will not behave as
it would if it were available at “compile” time. The dynamism is
arguably not worth the extra implementation effort. This snippet
demonstrates the current behavior:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">prn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span><span class="nb">print</span> <span class="n">args</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">a</span><span class="p">:</span>

<span class="gp">... </span>   <span class="fm">__setattr__</span><span class="o">=</span><span class="n">prn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="o">=</span><span class="mi">5</span>
<span class="go">(&lt;__main__.a instance at 882890&gt;, &#39;foo&#39;, 5)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">b</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bi</span><span class="o">=</span><span class="n">b</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bi</span><span class="o">.</span><span class="fm">__setattr__</span><span class="o">=</span><span class="n">prn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">foo</span><span class="o">=</span><span class="mi">5</span>
</pre></div>
</div>
</li>
<li>Assignment to __dict__[“XXX”] can overwrite the attribute
access handler for __attr_XXX__. Typically the access handlers will
store information away in private __XXX variables</li>
<li>An attribute access handler that attempts to call setattr or getattr
on the object itself can cause an infinite loop (as with <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code>)
Once again, the solution is to use a special (typically private)
variable such as __XXX.</li>
</ol>
</section>
<section id="note">
<h2><a class="toc-backref" href="#note">Note</a></h2>
<p>The descriptor mechanism described in <a class="reference external" href="../pep-0252">PEP 252</a> is powerful enough
to support this more directly.  A ‘getset’ constructor may be
added to the language making this possible:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x</span>
    <span class="k">def</span> <span class="nf">set_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__x</span> <span class="o">=</span> <span class="n">v</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">getset</span><span class="p">(</span><span class="n">get_x</span><span class="p">,</span> <span class="n">set_x</span><span class="p">)</span>
</pre></div>
</div>
<p>Additional syntactic sugar might be added, or a naming convention
could be recognized.</p>
</section>
</section>
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/master/pep-0213.txt">https://github.com/python/peps/blob/master/pep-0213.txt</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/master/pep-0213.txt">2017-11-11 19:28:55 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#">PEP 213 – Attribute Access Handlers</a><ul>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#justification">Justification</a><ul>
<li><a class="reference internal" href="#scenario-1">Scenario 1</a></li>
<li><a class="reference internal" href="#scenario-2">Scenario 2</a></li>
<li><a class="reference internal" href="#scenario-3">Scenario 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#current-solution">Current Solution</a></li>
<li><a class="reference internal" href="#proposed-syntax">Proposed Syntax</a></li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
<li><a class="reference internal" href="#proposed-implementation">Proposed Implementation</a></li>
<li><a class="reference internal" href="#caveats">Caveats</a></li>
<li><a class="reference internal" href="#note">Note</a></li>
</ul>
</li>
</ul>

            <br />
            <strong><a href="https://github.com/python/peps/blob/master/pep-0213.txt">Page Source (GitHub)</a></strong>
        </nav>
    </section>
    <script src="../_static/doctools.js"></script>
</body>
</html>