
<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PEP 646 – Variadic Generics | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png"/>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/mq.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)"/>
</head>
<body>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 646 – Variadic Generics</li>
            </ul>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 646 – Variadic Generics</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">PEP</dt>
<dd class="field-odd">646</dd>
<dt class="field-even">Title</dt>
<dd class="field-even">Variadic Generics</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd">Mark Mendoza &lt;mendoza.mark.a&#32;&#97;t&#32;gmail.com&gt;,
Matthew Rahtz &lt;mrahtz&#32;&#97;t&#32;google.com&gt;,
Pradeep Kumar Srinivasan &lt;gohanpra&#32;&#97;t&#32;gmail.com&gt;,
Vincent Siles &lt;vsiles&#32;&#97;t&#32;fb.com&gt;</dd>
<dt class="field-even">Sponsor</dt>
<dd class="field-even">Guido van Rossum &lt;guido&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-odd">Status</dt>
<dd class="field-odd">Draft</dd>
<dt class="field-even">Type</dt>
<dd class="field-even">Standards Track</dd>
<dt class="field-odd">Created</dt>
<dd class="field-odd">16-Sep-2020</dd>
<dt class="field-even">Python-Version</dt>
<dd class="field-even">3.10</dd>
<dt class="field-odd">Post-History</dt>
<dd class="field-odd">07-Oct-2020, 23-Dec-2020, 29-Dec-2020</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<h2>Contents</h2>
<ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#summary-examples">Summary Examples</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#type-variable-tuples">Type Variable Tuples</a><ul>
<li><a class="reference internal" href="#type-variable-tuples-must-always-be-unpacked">Type Variable Tuples Must Always be Unpacked</a></li>
<li><a class="reference internal" href="#unpack-for-backwards-compatibility"><code class="docutils literal notranslate"><span class="pre">Unpack</span></code> for Backwards Compatibility</a></li>
<li><a class="reference internal" href="#variance-type-constraints-and-type-bounds-not-yet-supported">Variance, Type Constraints and Type Bounds: Not (Yet) Supported</a></li>
<li><a class="reference internal" href="#behaviour-when-type-parameters-are-not-specified">Behaviour when Type Parameters are not Specified</a></li>
<li><a class="reference internal" href="#type-variable-tuples-must-have-known-length">Type Variable Tuples Must Have Known Length</a></li>
<li><a class="reference internal" href="#type-variable-tuple-equality">Type Variable Tuple Equality</a></li>
<li><a class="reference internal" href="#multiple-type-variable-tuples-not-allowed">Multiple Type Variable Tuples: Not Allowed</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-concatenation">Type Concatenation</a></li>
<li><a class="reference internal" href="#args-as-a-type-variable-tuple"><code class="docutils literal notranslate"><span class="pre">*args</span></code> as a Type Variable Tuple</a></li>
<li><a class="reference internal" href="#type-variable-tuples-with-callable">Type Variable Tuples with <code class="docutils literal notranslate"><span class="pre">Callable</span></code></a></li>
<li><a class="reference internal" href="#aliases">Aliases</a></li>
<li><a class="reference internal" href="#overloads-for-accessing-individual-types">Overloads for Accessing Individual Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale-and-rejected-ideas">Rationale and Rejected Ideas</a><ul>
<li><a class="reference internal" href="#shape-arithmetic">Shape Arithmetic</a></li>
<li><a class="reference internal" href="#supporting-variadicity-through-aliases">Supporting Variadicity Through Aliases</a></li>
<li><a class="reference internal" href="#construction-of-typevartuple">Construction of <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a></li>
<li><a class="reference internal" href="#id9">Behaviour when Type Parameters are not Specified</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#appendix-a-shape-typing-use-cases">Appendix A: Shape Typing Use Cases</a><ul>
<li><a class="reference internal" href="#use-case-1-specifying-shape-values">Use Case 1: Specifying Shape Values</a></li>
<li><a class="reference internal" href="#use-case-2-specifying-shape-semantics">Use Case 2: Specifying Shape Semantics</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#why-not-both">Why Not Both?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-b-shaped-types-vs-named-axes">Appendix B: Shaped Types vs Named Axes</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#resources">Resources</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract">Abstract</a></h2>
<p><a class="reference external" href="../pep-0484">PEP 484</a> introduced <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code>, enabling creation of generics parameterised
with a single type. In this PEP, we introduce <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code>, enabling parameterisation
with an <em>arbitrary</em> number of types - that is, a <em>variadic</em> type variable,
enabling <em>variadic</em> generics. This enables a wide variety of use cases.
In particular, it allows the type of array-like structures
in numerical computing libraries such as NumPy and TensorFlow to be
parameterised with the array <em>shape</em>, enabling static type checkers
to catch shape-related bugs in code that uses these libraries.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation">Motivation</a></h2>
<p>Variadic generics have long been a requested feature, for a myriad of
use cases <a class="footnote-reference brackets" href="#typing193" id="id1">4</a>. One particular use case - a use case with potentially
large impact, and the main case this PEP targets - concerns typing in
numerical libraries.</p>
<p>In the context of numerical computation with libraries such as NumPy and TensorFlow,
the <em>shape</em> of variables is often just as important as the variable <em>type</em>.
For example, consider the following function which converts a batch <a class="footnote-reference brackets" href="#batch" id="id2">1</a>
of videos to grayscale:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to_gray</span><span class="p">(</span><span class="n">videos</span><span class="p">:</span> <span class="n">Array</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>From the signature alone, it is not obvious what shape of array <a class="footnote-reference brackets" href="#array" id="id3">2</a>
we should pass for the <code class="docutils literal notranslate"><span class="pre">videos</span></code> argument. Possibilities include, for
example,</p>
<blockquote>
<div>batch × time × height × width × channels</div></blockquote>
<p>and</p>
<blockquote>
<div>time × batch × channels × height × width. <a class="footnote-reference brackets" href="#timebatch" id="id4">3</a></div></blockquote>
<p>This is important for three reasons:</p>
<ul class="simple">
<li><strong>Documentation</strong>. Without the required shape being clear in the signature,
the user must hunt in the docstring or the code in question to determine
what the input/output shape requirements are.</li>
<li><strong>Catching shape bugs before runtime</strong>. Ideally, use of incorrect shapes
should be an error we can catch ahead of time using static analysis.
(This is particularly important for machine learning code, where iteration
times can be slow.)</li>
<li><strong>Preventing subtle shape bugs</strong>. In the worst case, use of the wrong shape
will result in the program appearing to run fine, but with a subtle bug
that can take days to track down. (See <a class="reference external" href="https://spinningup.openai.com/en/latest/spinningup/exercise2_2_soln.html">this exercise</a> <a class="footnote-reference brackets" href="#id21" id="id22">16</a> in a popular machine learning
tutorial for a particularly pernicious example.)</li>
</ul>
<p>Ideally, we should have some way of making shape requirements explicit in
type signatures. Multiple proposals <a class="footnote-reference brackets" href="#numeric-stack" id="id5">6</a> <a class="footnote-reference brackets" href="#typing-ideas" id="id6">7</a>
<a class="footnote-reference brackets" href="#syntax-proposal" id="id7">9</a> have suggested the use of the standard generics syntax for
this purpose. We would write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to_gray</span><span class="p">(</span><span class="n">videos</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Time</span><span class="p">,</span> <span class="n">Batch</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">,</span> <span class="n">Channels</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>However, note that arrays can be of arbitrary rank - <code class="docutils literal notranslate"><span class="pre">Array</span></code> as used above is
generic in an arbitrary number of axes. One way around this would be to use a different
<code class="docutils literal notranslate"><span class="pre">Array</span></code> class for each rank…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Axis1</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Axis1&#39;</span><span class="p">)</span>
<span class="n">Axis2</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Axis2&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Array1</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Axis1</span><span class="p">]):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">Array2</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Axis1</span><span class="p">,</span> <span class="n">Axis2</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>…but this would be cumbersome, both for users (who would have to sprinkle 1s and 2s
and so on throughout their code) and for the authors of array libraries (who would have to duplicate implementations throughout multiple classes).</p>
<p>Variadic generics are necessary for an <code class="docutils literal notranslate"><span class="pre">Array</span></code> that is generic in an arbitrary
number of axes to be cleanly defined as a single class.</p>
</section>
<section id="summary-examples">
<h2><a class="toc-backref" href="#summary-examples">Summary Examples</a></h2>
<p>Cutting right to the chase, this PEP allows an <code class="docutils literal notranslate"><span class="pre">Array</span></code> class that is generic
in its shape (and datatype) to be defined using a newly-introduced
arbitrary-length type variable, <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code>, as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">TypeVarTuple</span>

<span class="n">DType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;DType&#39;</span><span class="p">)</span>
<span class="n">Shape</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Shape&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Such an <code class="docutils literal notranslate"><span class="pre">Array</span></code> can be used to support a number of different kinds of
shape annotations. For example, we can add labels describing the
semantic meaning of each axis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">Height</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Height&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">Width</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Width&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
</pre></div>
</div>
<p>We could also add annotations describing the actual size of each axis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span> <span class="k">as</span> <span class="n">L</span>


<span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="mi">480</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">640</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
</pre></div>
</div>
<p>For consistency, we use semantic axis annotations as the basis of the examples
in this PEP, but this PEP is agnostic about which of these two (or possibly other)
ways of using <code class="docutils literal notranslate"><span class="pre">Array</span></code> is preferable; that decision is left to library authors.</p>
<p>(Note also that for the rest of this PEP, for conciseness of example, we use
a simpler version of <code class="docutils literal notranslate"><span class="pre">Array</span></code> which is generic only in the shape - <em>not</em> the
data type.)</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification">Specification</a></h2>
<p>In order to support the above use cases, we introduce <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code>. This serves as a placeholder not for a single type but for an <em>arbitrary</em> number of types, and behaving like a number of <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> instances packed in a <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>.</p>
<p>In addition, we introduce a new use for the star operator: to ‘unpack’
<code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> instances, in order to access the type variables
contained in the tuple.</p>
<section id="type-variable-tuples">
<h3><a class="toc-backref" href="#type-variable-tuples">Type Variable Tuples</a></h3>
<p>In the same way that a normal type variable is a stand-in for a single type,
a type variable <em>tuple</em> is a stand-in for an arbitrary number of types (zero or
more) in a flat ordered list.</p>
<p>Type variable tuples are created with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVarTuple</span>

<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Type variable tuples behave like a number of individual type variables packed in a
<code class="docutils literal notranslate"><span class="pre">Tuple</span></code>. To understand this, consider the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Shape</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Shape&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">Height</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Height&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">Width</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Width&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Shape</span></code> type variable tuple here behaves like <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code> are type variables. To use these type variables
as type parameters of <code class="docutils literal notranslate"><span class="pre">Array</span></code>, we must <em>unpack</em> the type variable tuple using
the star operator: <code class="docutils literal notranslate"><span class="pre">*Shape</span></code>. The signature of <code class="docutils literal notranslate"><span class="pre">Array</span></code> then behaves
as if we had simply written <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Array(Generic[T1,</span> <span class="pre">T2]):</span> <span class="pre">...</span></code>.</p>
<p>In contrast to <code class="docutils literal notranslate"><span class="pre">Generic[T1,</span> <span class="pre">T2]</span></code>, however, <code class="docutils literal notranslate"><span class="pre">Generic[*Shape]</span></code> allows
us to parameterise the class with an <em>arbitrary</em> number of type parameters.
That is, in addition to being able to define rank-2 arrays such as
<code class="docutils literal notranslate"><span class="pre">Array[Height,</span> <span class="pre">Width]</span></code>, we could also define rank-3 arrays, rank-4 arrays,
and so on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Time</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">Batch</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Batch&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
<span class="n">z</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Time</span><span class="p">,</span> <span class="n">Batch</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
</pre></div>
</div>
<p>Type variable tuples can be used anywhere a normal <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> can.
This includes class definitions, as shown above, as well as function
signatures and variable annotations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>

    <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">Height</span><span class="p">(</span><span class="mi">480</span><span class="p">),</span> <span class="n">Width</span><span class="p">(</span><span class="mi">640</span><span class="p">))</span>
<span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Inferred type is Array[Height, Width]</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>   <span class="c1">#        ...    is Array[Height, Width]</span>
</pre></div>
</div>
<section id="type-variable-tuples-must-always-be-unpacked">
<h4><a class="toc-backref" href="#type-variable-tuples-must-always-be-unpacked">Type Variable Tuples Must Always be Unpacked</a></h4>
<p>Note that in the previous example, the <code class="docutils literal notranslate"><span class="pre">shape</span></code> argument to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
was annotated as <code class="docutils literal notranslate"><span class="pre">Tuple[*Shape]</span></code>. Why is this necessary - if <code class="docutils literal notranslate"><span class="pre">Shape</span></code>
behaves like <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2,</span> <span class="pre">...]</span></code>, couldn’t we have annotated the <code class="docutils literal notranslate"><span class="pre">shape</span></code>
argument as <code class="docutils literal notranslate"><span class="pre">Shape</span></code> directly?</p>
<p>This is, in fact, deliberately not possible: type variable tuples must
<em>always</em> be used unpacked (that is, prefixed by the star operator). This is
for two reasons:</p>
<ul class="simple">
<li>To avoid potential confusion about whether to use a type variable tuple
in a packed or unpacked form (“Hmm, should I write ‘<code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">Shape</span></code>’,
or ‘<code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">Tuple[Shape]</span></code>’, or ‘<code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">Tuple[*Shape]</span></code>’…?”)</li>
<li>To improve readability: the star also functions as an explicit visual
indicator that the type variable tuple is not a normal type variable.</li>
</ul>
</section>
<section id="unpack-for-backwards-compatibility">
<h4><a class="toc-backref" href="#unpack-for-backwards-compatibility"><code class="docutils literal notranslate"><span class="pre">Unpack</span></code> for Backwards Compatibility</a></h4>
<p>Note that the use of the star operator in this context requires a grammar change,
and is therefore available only in new versions of Python. To enable use of type
variable tuples in older versions of Python, we introduce the <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> type
operator that can be used in place of the star operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Unpacking using the star operator in new versions of Python</span>
<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]):</span> <span class="o">...</span>

<span class="c1"># Unpacking using ``Unpack`` in older versions of Python</span>
<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Shape</span><span class="p">]]):</span> <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="variance-type-constraints-and-type-bounds-not-yet-supported">
<h4><a class="toc-backref" href="#variance-type-constraints-and-type-bounds-not-yet-supported">Variance, Type Constraints and Type Bounds: Not (Yet) Supported</a></h4>
<p>To keep this PEP minimal, <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> does not yet support specification of:</p>
<ul class="simple">
<li>Variance (e.g. <code class="docutils literal notranslate"><span class="pre">TypeVar('T',</span> <span class="pre">covariant=True)</span></code>)</li>
<li>Type constraints (<code class="docutils literal notranslate"><span class="pre">TypeVar('T',</span> <span class="pre">int,</span> <span class="pre">float)</span></code>)</li>
<li>Type bounds (<code class="docutils literal notranslate"><span class="pre">TypeVar('T',</span> <span class="pre">bound=ParentClass)</span></code>)</li>
</ul>
<p>We leave the decision of how these arguments should behave to a future PEP, when variadic generics have been tested in the field. As of this PEP, type variable tuples are
invariant.</p>
</section>
<section id="behaviour-when-type-parameters-are-not-specified">
<h4><a class="toc-backref" href="#behaviour-when-type-parameters-are-not-specified">Behaviour when Type Parameters are not Specified</a></h4>
<p>When a generic class parameterised by a type variable tuple is used without
any type parameters, it behaves as if its type parameters are ‘<code class="docutils literal notranslate"><span class="pre">Any,</span> <span class="pre">...</span></code>’
(an arbitrary number of <code class="docutils literal notranslate"><span class="pre">Any</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">takes_any_array</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">):</span> <span class="o">...</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span>
<span class="n">takes_any_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Valid</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Time</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span>
<span class="n">takes_any_array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Also valid</span>
</pre></div>
</div>
<p>This enables gradual typing: existing functions accepting, for example,
a plain TensorFlow <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> will still be valid even if <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> is made
generic and calling code passes a <code class="docutils literal notranslate"><span class="pre">Tensor[Height,</span> <span class="pre">Width]</span></code>.</p>
<p>This also works in the opposite direction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">takes_specific_array</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">z</span><span class="p">:</span> <span class="n">Array</span>
<span class="n">takes_specific_array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>This way, even if libraries are updated to use types like <code class="docutils literal notranslate"><span class="pre">Array[Height,</span> <span class="pre">Width]</span></code>,
users of those libraries won’t be forced to also apply type annotations to
all of their code; users still have a choice about what parts of their code
to type and which parts to not.</p>
</section>
<section id="type-variable-tuples-must-have-known-length">
<h4><a class="toc-backref" href="#type-variable-tuples-must-have-known-length">Type Variable Tuples Must Have Known Length</a></h4>
<p>Type variables tuples may not be bound to a type with unknown length.
That is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># NOT valid; Ts would be bound to ``Tuple[float, ...]``</span>
</pre></div>
</div>
<p>If this is confusing - didn’t we say that type variable tuples are a stand-in
for an <em>arbitrary</em> number of types? - note the difference between the
length of the type variable tuple <em>itself</em>, and the length of the type it is
<em>bound</em> to. Type variable tuples themselves can be of arbitrary length -
that is, they can be bound to <code class="docutils literal notranslate"><span class="pre">Tuple[int]</span></code>, <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">int]</span></code>, and
so on - but the types they are bound to must be of known length -
that is, <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">int]</span></code>, but not <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code>.</p>
<p>Note that, as a result of this rule, omitting the type parameter list is the
<em>only</em> way of instantiating a generic type with an arbitrary number of
type parameters. (We plan to introduce a more deliberate syntax for this
case in a future PEP.) For example, an unparameterised <code class="docutils literal notranslate"><span class="pre">Array</span></code> may
<em>behave</em> like <code class="docutils literal notranslate"><span class="pre">Array[Any,</span> <span class="pre">...]</span></code>, but it cannot be instantiated using
<code class="docutils literal notranslate"><span class="pre">Array[Any,</span> <span class="pre">...]</span></code>, because this would bind its type variable tuple to <code class="docutils literal notranslate"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span>            <span class="c1"># Valid</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># Error</span>
<span class="n">z</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># Error</span>
</pre></div>
</div>
</section>
<section id="type-variable-tuple-equality">
<h4><a class="toc-backref" href="#type-variable-tuple-equality">Type Variable Tuple Equality</a></h4>
<p>If the same <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> instance is used in multiple places in a signature
or class, a valid type inference might be to bind the <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> to
a <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> of a <code class="docutils literal notranslate"><span class="pre">Union</span></code> of types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg1</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">],</span> <span class="n">arg2</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,)</span>
<span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># Can Ts be bound to Tuple[int | str]?</span>
</pre></div>
</div>
<p>We do <em>not</em> allow this; type unions may <em>not</em> appear within the <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>.
If a type variable tuple appears in multiple places in a signature,
the types must match exactly (the list of type parameters must be the same
length, and the type parameters themselves must be identical):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pointwise_multiply</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">],</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">]</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Width</span><span class="p">]</span>
<span class="n">z</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span>
<span class="n">pointwise_multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># Valid</span>
<span class="n">pointwise_multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># Error</span>
<span class="n">pointwise_multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>  <span class="c1"># Error</span>
</pre></div>
</div>
</section>
<section id="multiple-type-variable-tuples-not-allowed">
<h4><a class="toc-backref" href="#multiple-type-variable-tuples-not-allowed">Multiple Type Variable Tuples: Not Allowed</a></h4>
<p>As of this PEP, only a single type variable tuple may appear in a type parameter list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Ts1</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts2</span><span class="p">]):</span> <span class="o">...</span>  <span class="c1"># Error</span>
</pre></div>
</div>
</section>
</section>
<section id="type-concatenation">
<h3><a class="toc-backref" href="#type-concatenation">Type Concatenation</a></h3>
<p>Type variable tuples don’t have to be alone; normal types can be
prefixed and/or suffixed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Shape</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Shape&#39;</span><span class="p">)</span>
<span class="n">Batch</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Batch&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">Channels</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;Channels&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_batch_axis</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
<span class="k">def</span> <span class="nf">del_batch_axis</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
<span class="k">def</span> <span class="nf">add_batch_channels</span><span class="p">(</span>
  <span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="n">Channels</span><span class="p">]:</span> <span class="o">...</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">add_batch_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>      <span class="c1"># Inferred type is Array[Batch, Height, Width]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">del_batch_axis</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>      <span class="c1"># Array[Height, Width]</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">add_batch_channels</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># Array[Batch, Height, Width, Channels]</span>
</pre></div>
</div>
<p>Normal <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> instances can also be prefixed and/or suffixed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">prefix_tuple</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]:</span> <span class="o">...</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">prefix_tuple</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="c1"># Inferred type of z is Tuple[int, bool, str]</span>
</pre></div>
</div>
</section>
<section id="args-as-a-type-variable-tuple">
<h3><a class="toc-backref" href="#args-as-a-type-variable-tuple"><code class="docutils literal notranslate"><span class="pre">*args</span></code> as a Type Variable Tuple</a></h3>
<p><a class="reference external" href="../pep-0484">PEP 484</a> states that when a type annotation is provided for <code class="docutils literal notranslate"><span class="pre">*args</span></code>, every argument
must be of the type annotated. That is, if we specify <code class="docutils literal notranslate"><span class="pre">*args</span></code> to be type <code class="docutils literal notranslate"><span class="pre">int</span></code>,
then <em>all</em> arguments must be of type <code class="docutils literal notranslate"><span class="pre">int</span></code>. This limits our ability to specify
the type signatures of functions that take heterogeneous argument types.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">*args</span></code> is annotated as a type variable tuple, however, the types of the
individual arguments become the types in the type variable tuple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">args_to_tuple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]:</span> <span class="o">...</span>

<span class="n">args_to_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>  <span class="c1"># Inferred type is Tuple[int, str]</span>
</pre></div>
</div>
<p>If no arguments are passed, the type variable tuple behaves like an
empty tuple, <code class="docutils literal notranslate"><span class="pre">Tuple[()]</span></code>.</p>
<p>Note that, in keeping with the rule that type variable tuples must always
be used unpacked, annotating <code class="docutils literal notranslate"><span class="pre">*args</span></code> as being a plain type variable tuple
instance is <em>not</em> allowed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Ts</span><span class="p">):</span> <span class="o">...</span>  <span class="c1"># NOT valid</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*args</span></code> is the only case where an argument can be annotated as <code class="docutils literal notranslate"><span class="pre">*Ts</span></code> directly;
other arguments should use <code class="docutils literal notranslate"><span class="pre">*Ts</span></code> to parameterise something else, e.g. <code class="docutils literal notranslate"><span class="pre">Tuple[*Ts]</span></code>.
If <code class="docutils literal notranslate"><span class="pre">*args</span></code> itself is annotated as <code class="docutils literal notranslate"><span class="pre">Tuple[*Ts]</span></code>, the old behaviour still applies:
all arguments must be a <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> parameterised with the same types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">foo</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>    <span class="c1"># Valid</span>
<span class="n">foo</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Error</span>
<span class="n">foo</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,))</span>  <span class="c1"># Error</span>
</pre></div>
</div>
<p>Following <a class="reference internal" href="#type-variable-tuples-must-have-known-length">Type Variable Tuples Must Have Known Length</a>, note
that the following should <em>not</em> type-check as valid (even though it is, of
course, valid at runtime):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span><span class="p">):</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
  <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># NOT valid</span>
</pre></div>
</div>
<p>Finally, note that a type variable tuple may <em>not</em> be used as the type of
<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>. (We do not yet know of a use case for this feature, so we prefer
to leave the ground fresh for a potential future PEP.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># NOT valid</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="type-variable-tuples-with-callable">
<h3><a class="toc-backref" href="#type-variable-tuples-with-callable">Type Variable Tuples with <code class="docutils literal notranslate"><span class="pre">Callable</span></code></a></h3>
<p>Type variable tuples can also be used in the arguments section of a
<code class="docutils literal notranslate"><span class="pre">Callable</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Process</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="o">*</span><span class="n">Ts</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
  <span class="p">):</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arg2</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span> <span class="o">...</span>

<span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">))</span>  <span class="c1"># Valid</span>
<span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># Error</span>
</pre></div>
</div>
<p>Other types and normal type variables can also be prefixed/suffixed
to the type variable tuple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]]):</span> <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="aliases">
<h3><a class="toc-backref" href="#aliases">Aliases</a></h3>
<p>Generic aliases can be created using a type variable tuple in
a similar way to regular type variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IntTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
<span class="n">NamedArray</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]]</span>

<span class="n">IntTuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>  <span class="c1"># Equivalent to Tuple[int, float, bool]</span>
<span class="n">NamedArray</span><span class="p">[</span><span class="n">Height</span><span class="p">]</span>     <span class="c1"># Equivalent to Tuple[str, Array[Height]]</span>
</pre></div>
</div>
<p>As this example shows, all type parameters passed to the alias are
bound to the type variable tuple.</p>
<p>Importantly for our original <code class="docutils literal notranslate"><span class="pre">Array</span></code> example (see <a class="reference internal" href="#summary-examples">Summary Examples</a>), this
allows us to define convenience aliases for arrays of a fixed shape
or datatype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Shape</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Shape&#39;</span><span class="p">)</span>
<span class="n">DType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;DType&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>

<span class="c1"># E.g. Float32Array[Height, Width, Channels]</span>
<span class="n">Float32Array</span> <span class="o">=</span> <span class="n">Array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]</span>

<span class="c1"># E.g. Array1D[np.uint8]</span>
<span class="n">Array1D</span> <span class="o">=</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</pre></div>
</div>
<p>If an explicitly empty type parameter list is given, the type variable
tuple in the alias is set empty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IntTuple</span><span class="p">[()]</span>    <span class="c1"># Equivalent to Tuple[int]</span>
<span class="n">NamedArray</span><span class="p">[()]</span>  <span class="c1"># Equivalent to Tuple[str, Array[()]]</span>
</pre></div>
</div>
<p>If the type parameter list is omitted entirely, the alias is
compatible with arbitrary type parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">takes_float_array_of_any_shape</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Float32Array</span><span class="p">):</span> <span class="o">...</span>
<span class="n">x</span><span class="p">:</span> <span class="n">Float32Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
<span class="n">takes_float_array_of_any_shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Valid</span>

<span class="k">def</span> <span class="nf">takes_float_array_with_specific_shape</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Float32Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span>
<span class="p">):</span> <span class="o">...</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Float32Array</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
<span class="n">takes_float_array_with_specific_shape</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Valid</span>
</pre></div>
</div>
<p>Normal <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> instances can also be used in such aliases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Foo</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]</span>

<span class="c1"># T bound to str, Ts to Tuple[int]</span>
<span class="n">Foo</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="c1"># T bound to float, Ts to Tuple[()]</span>
<span class="n">Foo</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
<span class="c1"># T bound to Any, Ts to an arbitrary number of Any</span>
<span class="n">Foo</span>
</pre></div>
</div>
</section>
<section id="overloads-for-accessing-individual-types">
<h3><a class="toc-backref" href="#overloads-for-accessing-individual-types">Overloads for Accessing Individual Types</a></h3>
<p>For situations where we require access to each individual type in the type variable tuple,
overloads can be used with individual <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> instances in place of the type variable tuple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Shape</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Shape&#39;</span><span class="p">)</span>
<span class="n">Axis1</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Axis1&#39;</span><span class="p">)</span>
<span class="n">Axis2</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Axis2&#39;</span><span class="p">)</span>
<span class="n">Axis3</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Axis3&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>

  <span class="nd">@overload</span>
  <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Axis1</span><span class="p">,</span> <span class="n">Axis2</span><span class="p">]</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">Axis2</span><span class="p">,</span> <span class="n">Axis1</span><span class="p">]:</span> <span class="o">...</span>

  <span class="nd">@overload</span>
  <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Axis1</span><span class="p">,</span> <span class="n">Axis2</span><span class="p">,</span> <span class="n">Axis3</span><span class="p">]</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">Axis3</span><span class="p">,</span> <span class="n">Axis2</span><span class="p">,</span> <span class="n">Axis1</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>(For array shape operations in particular, having to specify
overloads for each possible rank is, of course, a rather cumbersome
solution. However, it’s the best we can do without additional type
manipulation mechanisms. We plan to introduce these in a future PEP.)</p>
</section>
</section>
<section id="rationale-and-rejected-ideas">
<h2><a class="toc-backref" href="#rationale-and-rejected-ideas">Rationale and Rejected Ideas</a></h2>
<section id="shape-arithmetic">
<h3><a class="toc-backref" href="#shape-arithmetic">Shape Arithmetic</a></h3>
<p>Considering the use case of array shapes in particular, note that as of
this PEP, it is not yet possible to describe arithmetic transformations
of array dimensions - for example,
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">repeat_each_element(x:</span> <span class="pre">Array[N])</span> <span class="pre">-&gt;</span> <span class="pre">Array[2*N]</span></code>. We consider
this out-of-scope for the current PEP, but plan to propose additional
mechanisms that <em>will</em> enable this in a future PEP.</p>
</section>
<section id="supporting-variadicity-through-aliases">
<h3><a class="toc-backref" href="#supporting-variadicity-through-aliases">Supporting Variadicity Through Aliases</a></h3>
<p>As noted in the introduction, it <em>is</em> possible to avoid variadic generics
by simply defining aliases for each possible number of type parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array1</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Axis1</span><span class="p">]):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">Array2</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Axis1</span><span class="p">,</span> <span class="n">Axis2</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>However, this seems somewhat clumsy - it requires users to unnecessarily
pepper their code with 1s, 2s, and so on for each rank necessary.</p>
</section>
<section id="construction-of-typevartuple">
<h3><a class="toc-backref" href="#construction-of-typevartuple">Construction of <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> began as <code class="docutils literal notranslate"><span class="pre">ListVariadic</span></code>, based on its naming in
an early implementation in Pyre.</p>
<p>We then changed this to <code class="docutils literal notranslate"><span class="pre">TypeVar(list=True)</span></code>, on the basis that a)
it better emphasises the similarity to <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code>, and b) the meaning
of ‘list’ is more easily understood than the jargon of ‘variadic’.</p>
<p>Once we’d decided that a variadic type variable should behave like a <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>,
we also considered <code class="docutils literal notranslate"><span class="pre">TypeVar(bound=Tuple)</span></code>, which is similarly intuitive
and accomplishes most what we wanted without requiring any new arguments to
<code class="docutils literal notranslate"><span class="pre">TypeVar</span></code>. However, we realised this may constrain us in the future, if
for example we want type bounds or variance to function slightly differently
for variadic type variables than what the semantics of <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> might
otherwise imply. Also, we may later wish to support arguments that should not be supported by regular type variables (such as <code class="docutils literal notranslate"><span class="pre">arbitrary_len</span></code> <a class="footnote-reference brackets" href="#arbitrary-len" id="id8">10</a>).</p>
<p>We therefore settled on <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code>.</p>
</section>
<section id="id9">
<h3><a class="toc-backref" href="#id9">Behaviour when Type Parameters are not Specified</a></h3>
<p>In order to support gradual typing, this PEP states that <em>both</em>
of the following examples should type-check correctly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">takes_any_array</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">):</span> <span class="o">...</span>
<span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span>
<span class="n">takes_any_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">takes_specific_array</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]):</span> <span class="o">...</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Array</span>
<span class="n">takes_specific_array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that this is in contrast to the behaviour of the only currently-existing
variadic type in Python, <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">takes_any_tuple</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span> <span class="o">...</span>
<span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">takes_any_tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Valid</span>

<span class="k">def</span> <span class="nf">takes_specific_tuple</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span> <span class="o">...</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Tuple</span>
<span class="n">takes_specific_tuple</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Error</span>
</pre></div>
</div>
<p>The rules for <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> were deliberately chosen such that the latter case
is an error: it was thought to be more likely that the programmer has made a
mistake than that the function expects a specific kind of <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> but the
specific kind of <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> passed is unknown to the type checker. Additionally,
<code class="docutils literal notranslate"><span class="pre">Tuple</span></code> is something of a special case, in that it is used to represent
immutable sequences. That is, if an object’s type is inferred to be an
unparameterised <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>, it is not necessarily because of incomplete typing.</p>
<p>In contrast, if an object’s type is inferred to be an unparameterised <code class="docutils literal notranslate"><span class="pre">Array</span></code>,
it is much more likely that the user has simply not yet fully annotated their
code, or that the signature of a shape-manipulating library function cannot yet
be expressed using the typing system and therefore returning a plain <code class="docutils literal notranslate"><span class="pre">Array</span></code>
is the only option. We rarely deal with arrays of truly arbitrary shape;
in certain cases, <em>some</em> parts of the shape will be arbitrary - for example,
when dealing with sequences, the first two parts of the shape are often
‘batch’ and ‘time’ - but we plan to support these cases explicitly in a
future PEP with a syntax such as <code class="docutils literal notranslate"><span class="pre">Array[Batch,</span> <span class="pre">Time,</span> <span class="pre">...]</span></code>.</p>
<p>We therefore made the decision to have variadic generics <em>other</em> than
<code class="docutils literal notranslate"><span class="pre">Tuple</span></code> behave differently, in order to give the user more flexibility
in how much of their code they wish to annotate, and to enable compatibility
between old unannotated code and new versions of libraries which do use
these type annotations.</p>
</section>
</section>
<section id="alternatives">
<h2><a class="toc-backref" href="#alternatives">Alternatives</a></h2>
<p>It should be noted that the approach outlined in this PEP to solve the
issue of shape checking in numerical libraries is <em>not</em> the only approach
possible. Examples of lighter-weight alternatives based on <em>runtime</em> checking include
ShapeGuard <a class="footnote-reference brackets" href="#shapeguard" id="id10">13</a>, tsanley <a class="footnote-reference brackets" href="#tsanley" id="id11">11</a>, and PyContracts <a class="footnote-reference brackets" href="#pycontracts" id="id12">12</a>.</p>
<p>While these existing approaches improve significantly on the default
situation of shape checking only being possible through lengthy and verbose
assert statements, none of them enable <em>static</em> analysis of shape correctness.
As mentioned in <a class="reference internal" href="#motivation">Motivation</a>, this is particularly desirable for
machine learning applications where, due to library and infrastructure complexity,
even relatively simple programs must suffer long startup times; iterating
by running the program until it crashes, as is necessary with these
existing runtime-based approaches, can be a tedious and frustrating
experience.</p>
<p>Our hope with this PEP is to begin to codify generic type annotations as
an official, language-supported way of dealing with shape correctness.
With something of a standard in place, in the long run, this will
hopefully enable a thriving ecosystem of tools for analysing and verifying
shape properties of numerical computing programs.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<p>In order to use the star operator for unpacking of <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> instances,
we would need to make two grammar changes:</p>
<ol class="arabic simple">
<li>Star expressions must be made valid in at least index operations.
For example, <code class="docutils literal notranslate"><span class="pre">Tuple[*Ts]</span></code> and <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">*Ts,</span> <span class="pre">T2]</span></code> would both
be valid. (This PEP does not allow multiple unpacked <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code>
instances to appear in a single parameter list, so <code class="docutils literal notranslate"><span class="pre">Tuple[*Ts1,</span> <span class="pre">*Ts2]</span></code>
would be a runtime error. Also note that star expressions would <em>not</em>
be valid in slice expressions -  e.g. <code class="docutils literal notranslate"><span class="pre">Tuple[*Ts:*Ts]</span></code> is
nonsensical and should remain invalid.)</li>
<li>We would need to make ‘<code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">*Ts</span></code>’ valid in function definitions.</li>
</ol>
<p>In both cases, at runtime the star operator would call <code class="docutils literal notranslate"><span class="pre">Ts.__iter__()</span></code>.
This would, in turn, return an instance of a helper class, e.g.
<code class="docutils literal notranslate"><span class="pre">UnpackedTypeVarTuple</span></code>, whose <code class="docutils literal notranslate"><span class="pre">repr</span></code> would be <code class="docutils literal notranslate"><span class="pre">*Ts</span></code>.</p>
<p>If these grammar changes are considered too burdensome, we could instead
simply use <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> - though in this case it might be better for us to
first decide whether there’s a better option.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> version of the PEP should be back-portable to previous
versions of Python.</p>
<p>Gradual typing is enabled by the fact that unparameterised variadic classes
are compatible with an arbitrary number of type parameters. This means
that if existing classes are made generic, a) all existing (unparameterised)
uses of the class will still work, and b) parameterised and unparameterised
versions of the class can be used together (relevant if, for example, library
code is updated to use parameters while user code is not, or vice-versa).</p>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation">Reference Implementation</a></h2>
<p>Two reference implementations of type-checking functionality exist:
one in Pyre, as of v0.9.0, and one in Pyright, as of v1.1.108.</p>
<p>A preliminary implementation of the <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> version of the PEP in CPython
is available in <a class="reference external" href="https://github.com/python/cpython/pull/24527">cpython/23527</a> <a class="footnote-reference brackets" href="#id17" id="id18">14</a>. A preliminary version of the version
using the star operator, based on an early implementation of <a class="reference external" href="../pep-0637">PEP 637</a>,
is also available at <a class="reference external" href="https://github.com/mrahtz/cpython/tree/pep637%2B646">mrahtz/cpython/pep637+646</a> <a class="footnote-reference brackets" href="#id19" id="id20">15</a>.</p>
</section>
<section id="appendix-a-shape-typing-use-cases">
<h2><a class="toc-backref" href="#appendix-a-shape-typing-use-cases">Appendix A: Shape Typing Use Cases</a></h2>
<p>To give this PEP additional context for those particularly interested in the
array typing use case, in this appendix we expand on the different ways
this PEP can be used for specifying shape-based subtypes.</p>
<section id="use-case-1-specifying-shape-values">
<h3><a class="toc-backref" href="#use-case-1-specifying-shape-values">Use Case 1: Specifying Shape Values</a></h3>
<p>The simplest way to parameterise array types is using <code class="docutils literal notranslate"><span class="pre">Literal</span></code>
type parameters - e.g. <code class="docutils literal notranslate"><span class="pre">Array[Literal[64],</span> <span class="pre">Literal[64]]</span></code>.</p>
<p>We can attach names to each parameter using normal type variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">matrix_vector_multiply</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">],</span> <span class="n">Array</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">K</span><span class="p">]:</span> <span class="o">...</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">64</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">32</span><span class="p">]]</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">32</span><span class="p">]]</span>
<span class="n">matrix_vector_multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1"># Result is Array[Literal[64]]</span>
</pre></div>
</div>
<p>Note that such names have a purely local scope. That is, the name
<code class="docutils literal notranslate"><span class="pre">K</span></code> is bound to <code class="docutils literal notranslate"><span class="pre">Literal[64]</span></code> only within <code class="docutils literal notranslate"><span class="pre">matrix_vector_multiply</span></code>. To put it another
way, there’s no relationship between the value of <code class="docutils literal notranslate"><span class="pre">K</span></code> in different
signatures. This is important: it would be inconvenient if every axis named <code class="docutils literal notranslate"><span class="pre">K</span></code>
were constrained to have the same value throughout the entire program.</p>
<p>The disadvantage of this approach is that we have no ability to enforce shape semantics across
different calls. For example, we can’t address the problem mentioned in <a class="reference internal" href="#motivation">Motivation</a>: if
one function returns an array with leading dimensions ‘Time × Batch’, and another function
takes the same array assuming leading dimensions ‘Batch × Time’, we have no way of detecting this.</p>
<p>The main advantage is that in some cases, axis sizes really are what we care about. This is true
for both simple linear algebra operations such as the matrix manipulations above, but also in more
complicated transformations such as convolutional layers in neural networks, where it would be of
great utility to the programmer to be able to inspect the array size after each layer using
static analysis. To aid this, in the future we would like to explore possibilities for additional
type operators that enable arithmetic on array shapes - for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat_each_element</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">Mul</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">]]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Such arithmetic type operators would only make sense if names such as <code class="docutils literal notranslate"><span class="pre">N</span></code> refer to axis size.</p>
</section>
<section id="use-case-2-specifying-shape-semantics">
<h3><a class="toc-backref" href="#use-case-2-specifying-shape-semantics">Use Case 2: Specifying Shape Semantics</a></h3>
<p>A second approach (the one that most of the examples in this PEP are based around)
is to forgo annotation with actual axis size, and instead annotate axis <em>type</em>.</p>
<p>This would enable us to solve the problem of enforcing shape properties across calls.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># lib.py</span>

<span class="k">class</span> <span class="nc">Batch</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">class</span> <span class="nc">Time</span><span class="p">:</span> <span class="k">pass</span>

<span class="k">def</span> <span class="nf">make_array</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="n">Time</span><span class="p">]:</span> <span class="o">...</span>

<span class="c1"># user.py</span>

<span class="kn">from</span> <span class="nn">lib</span> <span class="kn">import</span> <span class="n">Batch</span><span class="p">,</span> <span class="n">Time</span>

<span class="c1"># `Batch` and `Time` have the same identity as in `lib`,</span>
<span class="c1"># so must take array as produced by `lib.make_array`</span>
<span class="k">def</span> <span class="nf">use_array</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="n">Time</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>Note that in this case, names are <em>global</em> (to the extent that we use the
same <code class="docutils literal notranslate"><span class="pre">Batch</span></code> type in different place). However, because names refer only
to axis <em>types</em>, this doesn’t constrain the <em>value</em> of certain axes to be
the same through (that is, this doesn’t constrain all axes named <code class="docutils literal notranslate"><span class="pre">Height</span></code>
to have a value of, say, 480 throughout).</p>
<p>The argument <em>for</em> this approach is that in many cases, axis <em>type</em> is the more
important thing to verify; we care more about which axis is which than what the
specific size of each axis is.</p>
<p>It also does not preclude cases where we wish to describe shape transformations
without knowing the type ahead of time. For example, we can still write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">matrix_vector_multiply</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">],</span> <span class="n">Array</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">K</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>We can then use this with:</p>
<blockquote>
<div>class Batch: pass
class Values: pass<p>batch_of_values: Array[Batch, Values]
value_weights: Array[Values]
matrix_vector_multiply(batch_of_values, value_weights)
# Result is Array[Batch]</p>
</div></blockquote>
<p>The disadvantages are the inverse of the advantages from use case 1.
In particular, this approach does not lend itself well to arithmetic
on axis types: <code class="docutils literal notranslate"><span class="pre">Mul[2,</span> <span class="pre">Batch]</span></code> would be as meaningless as <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">int</span></code>.</p>
</section>
<section id="discussion">
<h3><a class="toc-backref" href="#discussion">Discussion</a></h3>
<p>Note that use cases 1 and 2 are mutually exclusive in user code. Users
can verify size or semantic type but not both.</p>
<p>As of this PEP, we are agnostic about which approach will provide most benefit.
Since the features introduced in this PEP are compatible with both approaches, however,
we leave the door open.</p>
</section>
<section id="why-not-both">
<h3><a class="toc-backref" href="#why-not-both">Why Not Both?</a></h3>
<p>Consider the following ‘normal’ code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>Note that we have symbols for both the value of the thing (<code class="docutils literal notranslate"><span class="pre">x</span></code>) and the type of
the thing (<code class="docutils literal notranslate"><span class="pre">int</span></code>). Why can’t we do the same with axes? For example, with an imaginary
syntax, we could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">TimeValue</span><span class="p">:</span> <span class="n">TimeType</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>This would allow us to access the axis size (say, 32) through the symbol <code class="docutils literal notranslate"><span class="pre">TimeValue</span></code>
<em>and</em> the type through the symbol <code class="docutils literal notranslate"><span class="pre">TypeType</span></code>.</p>
<p>This might even be possible using existing syntax, through a second level of parameterisation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="n">TimeValue</span><span class="p">[</span><span class="n">TimeType</span><span class="p">]]):</span> <span class="o">..</span>
</pre></div>
</div>
<p>However, we leave exploration of this approach to the future.</p>
</section>
</section>
<section id="appendix-b-shaped-types-vs-named-axes">
<h2><a class="toc-backref" href="#appendix-b-shaped-types-vs-named-axes">Appendix B: Shaped Types vs Named Axes</a></h2>
<p>An issue related to those addressed by this PEP concerns
axis <em>selection</em>. For example, if we have an image stored in an array of shape 64×64x3,
we might wish to convert to black-and-white by computing the mean over the third
axis, <code class="docutils literal notranslate"><span class="pre">mean(image,</span> <span class="pre">axis=2)</span></code>. Unfortunately, the simple typo <code class="docutils literal notranslate"><span class="pre">axis=1</span></code> is
difficult to spot and will produce a result that means something completely different
(all while likely allowing the program to keep on running, resulting in a bug
that is serious but silent).</p>
<p>In response, some libraries have implemented so-called ‘named tensors’ (in this context,
‘tensor’ is synonymous with ‘array’), in which axes are selected not by index but by
label - e.g. <code class="docutils literal notranslate"><span class="pre">mean(image,</span> <span class="pre">axis='channels')</span></code>.</p>
<p>A question we are often asked about this PEP is: why not just use named tensors?
The answer is that we consider the named tensors approach insufficient, for two main reasons:</p>
<ul class="simple">
<li><strong>Static checking</strong> of shape correctness is not possible. As mentioned in <a class="reference internal" href="#motivation">Motivation</a>,
this is a highly desireable feature in machine learning code where iteration times
are slow by default.</li>
<li><strong>Interface documentation</strong> is still not possible with this approach. If a function should
<em>only</em> be willing to take array arguments that have image-like shapes, this cannot be stipulated
with named tensors.</li>
</ul>
<p>Additionally, there’s the issue of <strong>poor uptake</strong>. At the time of writing, named tensors
have only been implemented in a small number of numerical computing libraries. Possible explanations for this
include difficulty of implementation (the whole API must be modified to allow selection by axis name
instead of index), and lack of usefulness due to the fact that axis ordering conventions are often
strong enough that axis names provide little benefit (e.g. when working with images, 3D tensors are
basically <em>always</em> height × width × channels). However, ultimately we are still uncertain
why this is the case.</p>
<p>Can the named tensors approach be combined with the approach we advocate for in
this PEP? We’re not sure. One area of overlap is that in some contexts, we could do, say:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">,</span> <span class="n">Channels</span><span class="p">]</span>
<span class="n">im</span><span class="p">:</span> <span class="n">Image</span>
<span class="n">mean</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">Image</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Channels</span><span class="p">)</span>
</pre></div>
</div>
<p>Ideally, we might write something like <code class="docutils literal notranslate"><span class="pre">im:</span> <span class="pre">Array[Height=64,</span> <span class="pre">Width=64,</span> <span class="pre">Channels=3]</span></code> -
but this won’t be possible in the short term, due to the rejection of <a class="reference external" href="../pep-0637">PEP 637</a>.
In any case, our attitude towards this is mostly “Wait and see what happens before
taking any further steps”.</p>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes">Footnotes</a></h2>
<dl class="footnote brackets">
<dt class="label" id="batch"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd>‘Batch’ is machine learning parlance for ‘a number of’.</dd>
<dt class="label" id="array"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd>We use the term ‘array’ to refer to a matrix with an arbitrary
number of dimensions. In NumPy, the corresponding class is the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>;
in TensorFlow, the <code class="docutils literal notranslate"><span class="pre">Tensor</span></code>; and so on.</dd>
<dt class="label" id="timebatch"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd>If the shape begins with ‘batch × time’, then
<code class="docutils literal notranslate"><span class="pre">videos_batch[0][1]</span></code> would select the second frame of the first video. If the
shape begins with ‘time × batch’, then <code class="docutils literal notranslate"><span class="pre">videos_batch[1][0]</span></code> would select the
same frame.</dd>
</dl>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements">Acknowledgements</a></h2>
<p>Thank you to <strong>Alfonso Castaño</strong>, <strong>Antoine Pitrou</strong>, <strong>Bas v.B.</strong>, <strong>David Foster</strong>, <strong>Dimitris Vardoulakis</strong>, <strong>Eric Traut</strong>, <strong>Guido van Rossum</strong>, <strong>Jia Chen</strong>,
<strong>Lucio Fernandez-Arjona</strong>, <strong>Nikita Sobolev</strong>, <strong>Peilonrayz</strong>, <strong>Rebecca Chen</strong>,
<strong>Sergei Lebedev</strong>, and <strong>Vladimir Mikulik</strong> for helpful feedback and suggestions on
drafts of this PEP.</p>
<p>Thank you especially to <strong>Lucio</strong> for suggesting the star syntax (which has made multiple aspects of this proposal much more concise and intuitive), and to <strong>Stephan Hoyer</strong> for his kind <a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/message/UDM7Y6HLHQBKXQEBIBD5ZLB5XNPDZDXV/">endorsement</a> <a class="footnote-reference brackets" href="#id23" id="id24">17</a> of the PEP on the python-dev mailing list.</p>
</section>
<section id="resources">
<h2><a class="toc-backref" href="#resources">Resources</a></h2>
<p>Discussions on variadic generics in Python started in 2016 with Issue 193
on the python/typing GitHub repository <a class="footnote-reference brackets" href="#typing193" id="id13">4</a>.</p>
<p>Inspired by this discussion, <strong>Ivan Levkivskyi</strong> made a concrete proposal
at PyCon 2019, summarised in notes on ‘Type system improvements’ <a class="footnote-reference brackets" href="#type-improvements" id="id14">5</a>
and ‘Static typing of Python numeric stack’ <a class="footnote-reference brackets" href="#numeric-stack" id="id15">6</a>.</p>
<p>Expanding on these ideas, <strong>Mark Mendoza</strong> and <strong>Vincent Siles</strong> gave a presentation on
‘Variadic Type Variables for Decorators and Tensors’ <a class="footnote-reference brackets" href="#variadic-type-variables" id="id16">8</a> at the 2019 Python
Typing Summit.</p>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references">References</a></h2>
<dl class="footnote brackets">
<dt class="label" id="typing193"><span class="brackets">4</span><span class='fn-backref''><em> (<a href='#id1'>1</a>, <a href='#id13'>2</a>) </em></span></dt>
<dd>Python typing issue #193:
<a class="reference external" href="https://github.com/python/typing/issues/193">https://github.com/python/typing/issues/193</a></dd>
<dt class="label" id="type-improvements"><span class="brackets"><a class="fn-backref" href="#id14">5</a></span></dt>
<dd>Ivan Levkivskyi, ‘Type system improvements’, PyCon 2019:
<a class="reference external" href="https://paper.dropbox.com/doc/Type-system-improvements-HHOkniMG9WcCgS0LzXZAe">https://paper.dropbox.com/doc/Type-system-improvements-HHOkniMG9WcCgS0LzXZAe</a></dd>
<dt class="label" id="numeric-stack"><span class="brackets">6</span><span class='fn-backref''><em> (<a href='#id5'>1</a>, <a href='#id15'>2</a>) </em></span></dt>
<dd>Ivan Levkivskyi, ‘Static typing of Python numeric stack’, PyCon 2019:
<a class="reference external" href="https://paper.dropbox.com/doc/Static-typing-of-Python-numeric-stack-summary-6ZQzTkgN6e0oXko8fEWwN">https://paper.dropbox.com/doc/Static-typing-of-Python-numeric-stack-summary-6ZQzTkgN6e0oXko8fEWwN</a></dd>
<dt class="label" id="typing-ideas"><span class="brackets"><a class="fn-backref" href="#id6">7</a></span></dt>
<dd>Stephan Hoyer, ‘Ideas for array shape typing in Python’:
<a class="reference external" href="https://docs.google.com/document/d/1vpMse4c6DrWH5rq2tQSx3qwP_m_0lyn-Ij4WHqQqRHY/edit">https://docs.google.com/document/d/1vpMse4c6DrWH5rq2tQSx3qwP_m_0lyn-Ij4WHqQqRHY/edit</a></dd>
<dt class="label" id="variadic-type-variables"><span class="brackets"><a class="fn-backref" href="#id16">8</a></span></dt>
<dd>Mark Mendoza, ‘Variadic Type Variables for Decorators and Tensors’, Python Typing Summit 2019:
<a class="reference external" href="https://github.com/facebook/pyre-check/blob/ae85c0c6e99e3bbfc92ec55104bfdc5b9b3097b2/docs/Variadic_Type_Variables_for_Decorators_and_Tensors.pdf">https://github.com/facebook/pyre-check/blob/ae85c0c6e99e3bbfc92ec55104bfdc5b9b3097b2/docs/Variadic_Type_Variables_for_Decorators_and_Tensors.pdf</a></dd>
<dt class="label" id="syntax-proposal"><span class="brackets"><a class="fn-backref" href="#id7">9</a></span></dt>
<dd>Matthew Rahtz et al., ‘Shape annotation syntax proposal’:
<a class="reference external" href="https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit">https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit</a></dd>
<dt class="label" id="arbitrary-len"><span class="brackets"><a class="fn-backref" href="#id8">10</a></span></dt>
<dd>Discussion on Python typing-sig mailing list:
<a class="reference external" href="https://mail.python.org/archives/list/typing-sig&#64;python.org/thread/SQVTQYWIOI4TIO7NNBTFFWFMSMS2TA4J/">https://mail.python.org/archives/list/typing-sig&#64;python.org/thread/SQVTQYWIOI4TIO7NNBTFFWFMSMS2TA4J/</a></dd>
<dt class="label" id="tsanley"><span class="brackets"><a class="fn-backref" href="#id11">11</a></span></dt>
<dd>tsanley: <a class="reference external" href="https://github.com/ofnote/tsanley">https://github.com/ofnote/tsanley</a></dd>
<dt class="label" id="pycontracts"><span class="brackets"><a class="fn-backref" href="#id12">12</a></span></dt>
<dd>PyContracts: <a class="reference external" href="https://github.com/AndreaCensi/contracts">https://github.com/AndreaCensi/contracts</a></dd>
<dt class="label" id="shapeguard"><span class="brackets"><a class="fn-backref" href="#id10">13</a></span></dt>
<dd>ShapeGuard: <a class="reference external" href="https://github.com/Qwlouse/shapeguard">https://github.com/Qwlouse/shapeguard</a></dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id18">14</a></span></dt>
<dd><a class="reference external" href="https://github.com/python/cpython/pull/24527">https://github.com/python/cpython/pull/24527</a></dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id20">15</a></span></dt>
<dd><a class="reference external" href="https://github.com/mrahtz/cpython/tree/pep637%2B646">https://github.com/mrahtz/cpython/tree/pep637%2B646</a></dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id22">16</a></span></dt>
<dd><a class="reference external" href="https://spinningup.openai.com/en/latest/spinningup/exercise2_2_soln.html">https://spinningup.openai.com/en/latest/spinningup/exercise2_2_soln.html</a></dd>
<dt class="label" id="id23"><span class="brackets"><a class="fn-backref" href="#id24">17</a></span></dt>
<dd><a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/message/UDM7Y6HLHQBKXQEBIBD5ZLB5XNPDZDXV/">https://mail.python.org/archives/list/python-dev&#64;python.org/message/UDM7Y6HLHQBKXQEBIBD5ZLB5XNPDZDXV/</a></dd>
</dl>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/master/pep-0646.rst">https://github.com/python/peps/blob/master/pep-0646.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/master/pep-0646.rst">2021-04-18 18:59:20 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#">PEP 646 – Variadic Generics</a><ul>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#summary-examples">Summary Examples</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#type-variable-tuples">Type Variable Tuples</a><ul>
<li><a class="reference internal" href="#type-variable-tuples-must-always-be-unpacked">Type Variable Tuples Must Always be Unpacked</a></li>
<li><a class="reference internal" href="#unpack-for-backwards-compatibility"><code class="docutils literal notranslate"><span class="pre">Unpack</span></code> for Backwards Compatibility</a></li>
<li><a class="reference internal" href="#variance-type-constraints-and-type-bounds-not-yet-supported">Variance, Type Constraints and Type Bounds: Not (Yet) Supported</a></li>
<li><a class="reference internal" href="#behaviour-when-type-parameters-are-not-specified">Behaviour when Type Parameters are not Specified</a></li>
<li><a class="reference internal" href="#type-variable-tuples-must-have-known-length">Type Variable Tuples Must Have Known Length</a></li>
<li><a class="reference internal" href="#type-variable-tuple-equality">Type Variable Tuple Equality</a></li>
<li><a class="reference internal" href="#multiple-type-variable-tuples-not-allowed">Multiple Type Variable Tuples: Not Allowed</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-concatenation">Type Concatenation</a></li>
<li><a class="reference internal" href="#args-as-a-type-variable-tuple"><code class="docutils literal notranslate"><span class="pre">*args</span></code> as a Type Variable Tuple</a></li>
<li><a class="reference internal" href="#type-variable-tuples-with-callable">Type Variable Tuples with <code class="docutils literal notranslate"><span class="pre">Callable</span></code></a></li>
<li><a class="reference internal" href="#aliases">Aliases</a></li>
<li><a class="reference internal" href="#overloads-for-accessing-individual-types">Overloads for Accessing Individual Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale-and-rejected-ideas">Rationale and Rejected Ideas</a><ul>
<li><a class="reference internal" href="#shape-arithmetic">Shape Arithmetic</a></li>
<li><a class="reference internal" href="#supporting-variadicity-through-aliases">Supporting Variadicity Through Aliases</a></li>
<li><a class="reference internal" href="#construction-of-typevartuple">Construction of <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a></li>
<li><a class="reference internal" href="#id9">Behaviour when Type Parameters are not Specified</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#appendix-a-shape-typing-use-cases">Appendix A: Shape Typing Use Cases</a><ul>
<li><a class="reference internal" href="#use-case-1-specifying-shape-values">Use Case 1: Specifying Shape Values</a></li>
<li><a class="reference internal" href="#use-case-2-specifying-shape-semantics">Use Case 2: Specifying Shape Semantics</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#why-not-both">Why Not Both?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-b-shaped-types-vs-named-axes">Appendix B: Shaped Types vs Named Axes</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#resources">Resources</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</li>
</ul>

            <br />
            <strong><a href="https://github.com/python/peps/blob/master/pep-0646.rst">Page Source (GitHub)</a></strong>
        </nav>
    </section>
    <script src="../_static/doctools.js"></script>
</body>
</html>